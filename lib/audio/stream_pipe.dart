// A low-level streaming helper that downloads bytes in a background
// isolate and appends them to a growing file on disk.  The main isolate
// opens that file with media_kit so mpv can play from it while it grows.
// This avoids relying on higher-level libraries while still giving us
// precise control over a small (â‰ˆ5 s) RAM pre-buffer.
//
// Author: Auto-generated by AI

import 'dart:async';
import 'dart:io';
import 'dart:isolate';
import 'dart:typed_data';

/// Message types exchanged between isolates.
sealed class _Msg {}

class _DownloadRequest extends _Msg {
  final String url;
  final SendPort port;
  _DownloadRequest(this.url, this.port);
}

class _DownloadProgress extends _Msg {
  final Uint8List bytes;
  final bool done;
  _DownloadProgress(this.bytes, {this.done = false});
}

/// Spawns a new isolate that downloads [url] and streams raw bytes back
/// through a [Stream<Uint8List>].
class DownloaderStream {
  final String url;
  late final Stream<Uint8List> stream;
  late final Isolate _isolate;
  late final StreamController<Uint8List> _controller;

  DownloaderStream._(this.url);

  static Future<DownloaderStream> start(String url) async {
    final instance = DownloaderStream._(url);
    instance._controller = StreamController<Uint8List>(
      onCancel: () {
        instance._isolate.kill(priority: Isolate.immediate);
      },
    );
    final receive = ReceivePort();
    instance.stream = instance._controller.stream;

    receive.listen((dynamic msg) {
      if (msg is _DownloadProgress) {
        instance._controller.add(msg.bytes);
        if (msg.done) instance._controller.close();
      }
    });

    instance._isolate = await Isolate.spawn<_DownloadRequest>(_downloadIsolate, _DownloadRequest(url, receive.sendPort), debugName: 'DownloaderIsolate');
    return instance;
  }

  static Future<void> _downloadIsolate(_DownloadRequest req) async {
    final client = HttpClient();
    final uri = Uri.parse(req.url);
    final request = await client.getUrl(uri);
    final response = await request.close();

    final buffer = BytesBuilder();
    await for (var chunk in response) {
      req.port.send(_DownloadProgress(Uint8List.fromList(chunk)));
    }
    req.port.send(_DownloadProgress(Uint8List(0), done: true));
    client.close();
  }
}

/// Writes bytes coming from [source] into [file] as they arrive.
Future<void> pipeStreamToFile(Stream<Uint8List> source, RandomAccessFile file) async {
  await for (final chunk in source) {
    await file.writeFrom(chunk);
  }
}

Future<void> pipeStreamToIOSink(Stream<Uint8List> source, IOSink sink) async {
  await for (final chunk in source) {
    sink.add(chunk);
  }
  await sink.flush();
}
